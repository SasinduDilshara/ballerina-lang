Test-Case: output
Description: Test `find` function.
Labels: function-call-expr, regexp, find, method-call-expr, nil

import ballerina/lang.regexp;

function init() {
    var regExpr1 = re `here(1|\s)`;
    var regExpr2 = re ``;
    string str1 = "notherematchhere andthere1";
    regexp:Span? res1 = regExpr1.find("NotMatching");
    io:println(res1 is ()); // @output true

    regexp:Span? res2 = regExpr1.find(str1);
    io:println(res2 is regexp:Span); // @output true
    regexp:Span res2span = <regexp:Span> res2;
    io:println(res2span.startIndex); // @output 12
    io:println(res2span.endIndex);  // @output 17

    regexp:Span? res3 = regexp:find(re `here(1|\s)`, str1, 20);
    io:println(res3 is regexp:Span); // @output true
    regexp:Span res3span = <regexp:Span> res3;
    io:println(res3span.startIndex); // @output 21
    io:println(res3span.endIndex); // @output 26

    regexp:Span res4span = <regexp:Span> regExpr1.find(str1, 15);
    io:println(res4span.startIndex); // @output 21
    io:println(res4span.endIndex); // @output 26

    regexp:Span? res5 = re `here(1|\s)`.find("notherematchhere andthere1", 21);
    io:println(res5 is regexp:Span); // @output true
    regexp:Span res5span = <regexp:Span> res5;
    io:println(res5span.startIndex); // @output 21
    io:println(res5span.endIndex); // @output 26

    regexp:Span? res6 = re `${"hereandthere"}`.find("notherematchhereandthere", 10);
    io:println(res6 is regexp:Span); // @output true
    regexp:Span res6span = <regexp:Span> res6;
    io:println(res6span.startIndex); // @output 12
    io:println(res6span.endIndex); // @output 24

    regexp:Span? res7 = re ``.find("notherematchhere andthere1");
    io:println(res7 is regexp:Span); // @output true
    regexp:Span res7span = <regexp:Span> res7;
    io:println(res7span.startIndex); // @output 0
    io:println(res7span.endIndex);  // @output 0

    regexp:Span? res8 = regexp:find(re `(?im-sx:H+ere?!?)`, "notherematchhereandthere", 20);
    io:println(res8 is regexp:Span); // @output true
    regexp:Span res8span = <regexp:Span> res8;
    io:println(res8span.startIndex); // @output 20
    io:println(res8span.endIndex); // @output 24

    regexp:Span? res9 = regexp:find(re `^[a-z]{20}`, "notherematchhereandthere");
    io:println(res9 is regexp:Span); // @output true
    regexp:Span res9span = <regexp:Span> res9;
    io:println(res9span.startIndex); // @output 0
    io:println(res9span.endIndex); // @output 20

    regexp:Span? res10 = regexp:find(re `$[a-z]{5,10}`, "notherematchhereandthere");
    io:println(res10 is ()); // @output true

    regexp:Span? res11 = re `\d\D*\w\W\W\s\S\\d`.find("1AB<> C\\d");
    io:println(res11 is regexp:Span); // @output true
    regexp:Span res11span = <regexp:Span> res11;
    io:println(res11span.startIndex); // @output 0
    io:println(res11span.endIndex);  // @output 9

    regexp:Span? res12 = re `\p{sc=Greek}\P{Lu}`.find("ThisisGreekCharacterWithNumberÎ‘1");
    io:println(res12 is regexp:Span); // @output true
    regexp:Span res12span = <regexp:Span> res12;
    io:println(res12span.startIndex); // @output  30
    io:println(res12span.endIndex);  // @output 32
}

Test-Case: output
Description: Test `find` function at module level.
Labels: function-call-expr, regexp, find, method-call-expr

import ballerina/lang.regexp;

var regExpr = re `[0-2][0-4]:([0-5][0-9]|60)`;
regexp:Span? res1 = regExpr.find("does not match 34:23 but match 24:59");
regexp:Span? res2 = regexp:find(regExpr, "does not match 34:23 but match 24:59", 2);
regexp:Span? res4 = re `[0-2][0-4]:([0-5][0-9]|60)`.find("does not match 34:23 but match 24:59");

function init() {
    io:println(res1 is regexp:Span); // @output true
    regexp:Span resspan1 = <regexp:Span> res1;
    io:println(resspan1.startIndex); // @output 31
    io:println(resspan1.endIndex);  // @output 36

    io:println(res2 is regexp:Span); // @output true
    regexp:Span resspan2 = <regexp:Span> res2;
    io:println(resspan2.startIndex); // @output 31
    io:println(resspan2.endIndex);  // @output 36

    io:println(res3 is regexp:Span); // @output true
    regexp:Span resspan3 = <regexp:Span> res3;
    io:println(resspan3.startIndex); // @output 31
    io:println(resspan3.endIndex);  // @output 36

    io:println(res4 is regexp:Span); // @output true
    regexp:Span resspan4 = <regexp:Span> res4;
    io:println(resspan4.startIndex); // @output 31
    io:println(resspan4.endIndex);  // @output 36
}

Test-Case: error
Description: Test `find` function with negative range.
Labels: function-call-expr, regexp, find, method-call-expr

import ballerina/lang.regexp;

function errorFunction() {
    var regExpr1 = re `Here`;
    string str1 = "MatchHereAndHere";

    regexp:Span? _ = regExpr1.find(str1, -5); // @error index out of bound
}

Test-Case: output
Description: Test assignability of `find` function result.
Labels: function-call-expr, regexp, find, method-call-expr

import ballerina/lang.regexp;

function init() {
    var regExpr1 = re `Here`;
    string str1 = "MatchHereAndHere";
    any result1 = regExpr1.find(str1);
    io:println(result1 is regexp:Span); // @output true

    var result2 = regExpr1.find(str1, 7);
    io:println(result2 is regexp:Span); // @output true

    var result2 = regExpr1.find(str1, 14);
    io:println(result2 is ()); // @output true
}

Test-Case: error
Description: Test assigning the result of `find` function to an incompatible type.
Labels: function-call-expr, regexp, find, method-call-expr

import ballerina/lang.regexp;

function errorFunction() {
    var regExpr1 = re `MatchHereAndHere`;
    string str1 = "Here";

    regexp:Span _ = regExpr1.find(str1, 5); // @error expects a regexp:Span, but find() returns regexp:Span?

    int _ = regExpr1.find(str1); // @error expects a int, but find() returns regexp:Span?
}

Test-Case: error
Description: Test missing required parameters for `find` method.
Labels: function-call-expr, regexp, find, method-call-expr

import ballerina/lang.regexp;

function errorFunction() {
    var regExpr1 = re `regexp`;

    regexp:Span? _ = regExpr1.find(); // @error missing string argument

}

Test-Case: error
Description: Test passing invalid parameters to `find()` method.
Labels: function-call-expr, regexp, find, method-call-expr

import ballerina/lang.regexp;

function errorFunction() {
    var regExpr1 = re `Here`;

    regexp:Span? _ = regExpr1.find(12); // @error int is not a subtype of string

    regexp:Span? _ = regExpr1.find("MatchHereAndHere", "5"); // @error string is not a subtype of int
}

Test-Case: error
Description: Test passing too many parameters to `find()` method.
Labels: function-call-expr, regexp, find, method-call-expr

import ballerina/lang.regexp;

function errorFunction() {
    var regExpr1 = re `Here`;

    regexp:Span? _ = regExpr1.find("MatchHereAndHere", 5, 1); // @error too many arguments
}
